<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments on: Law Of Demeter: Extension Methods Donâ€™t Count</title>
	<atom:link href="http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/feed/" rel="self" type="application/rss+xml" />
	<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/</link>
	<description>Better Than Yesterday</description>
	<lastBuildDate>Tue, 15 Jan 2013 14:03:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.2</generator>
	<item>
		<title>By: Dathan Bennett</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-712</link>
		<dc:creator>Dathan Bennett</dc:creator>
		<pubDate>Fri, 26 Mar 2010 18:36:44 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-712</guid>
		<description>@dave-ilsw I think you&#039;re inferring properties of extension methods that don&#039;t exist.  Underneath the hood, all the FirstOrDefault() extension method does is essentially call GetEnumerator(), then MoveNext() on the enumerator.  If MoveNext() returned false, then return null, else return enumerator.Current.  It&#039;s the same code you&#039;d write if you did it on your own - it&#039;s just wrapped up in a convenient method, but one that is still external to the target.  The fact that you&#039;re using an extension method has no bearing on whether you&#039;re violating the LoD - it&#039;s what the extension method does that matters.

That having been said, the code sample looks just fine to me - no smell whatsoever.</description>
		<content:encoded><![CDATA[<p>@dave-ilsw I think you&#8217;re inferring properties of extension methods that don&#8217;t exist.  Underneath the hood, all the FirstOrDefault() extension method does is essentially call GetEnumerator(), then MoveNext() on the enumerator.  If MoveNext() returned false, then return null, else return enumerator.Current.  It&#8217;s the same code you&#8217;d write if you did it on your own &#8211; it&#8217;s just wrapped up in a convenient method, but one that is still external to the target.  The fact that you&#8217;re using an extension method has no bearing on whether you&#8217;re violating the LoD &#8211; it&#8217;s what the extension method does that matters.</p>
<p>That having been said, the code sample looks just fine to me &#8211; no smell whatsoever.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: dave-ilsw</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-711</link>
		<dc:creator>dave-ilsw</dc:creator>
		<pubDate>Thu, 25 Mar 2010 18:33:15 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-711</guid>
		<description>I don&#039;t see any way in which this use of an extension method could be considered a violation of LoD, because this lets you ask the collection to reach into it&#039;s own pocket and hand you the first or default item.

Failing to use an extension method, however, would be a clear violation of LoD, because then your code is reaching into the collection&#039;s pocket to fetch the first or default item instead of letting the collection do it.</description>
		<content:encoded><![CDATA[<p>I don&#8217;t see any way in which this use of an extension method could be considered a violation of LoD, because this lets you ask the collection to reach into it&#8217;s own pocket and hand you the first or default item.</p>
<p>Failing to use an extension method, however, would be a clear violation of LoD, because then your code is reaching into the collection&#8217;s pocket to fetch the first or default item instead of letting the collection do it.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Eric</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-710</link>
		<dc:creator>Eric</dc:creator>
		<pubDate>Thu, 25 Mar 2010 16:11:48 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-710</guid>
		<description>I agree. Extension methods are a form of method chaining, and while method chains do have a bunch of &#039;dots&#039; in them, they&#039;re not the same as the &#039;dots&#039; in LoD violations. Counting dots isn&#039;t the point.</description>
		<content:encoded><![CDATA[<p>I agree. Extension methods are a form of method chaining, and while method chains do have a bunch of &#8216;dots&#8217; in them, they&#8217;re not the same as the &#8216;dots&#8217; in LoD violations. Counting dots isn&#8217;t the point.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Michael A. Smith</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-709</link>
		<dc:creator>Michael A. Smith</dc:creator>
		<pubDate>Thu, 25 Mar 2010 15:48:20 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-709</guid>
		<description>As Nolan pretty much said, LoM is more of a principle than a law, and the crux of the principle is what needs to be focused on and not the syntactic evidence of its application (or lack thereof).  With this understanding, I would no longer call extension methods, particularly those of the LINQ variety, simple syntactic sugar.

You can refactor any LoM violating line of code into something that doesn&#039;t appear to violate LoM, by extracting a method or, more-so, a helper class.  Your refactoring, depending on what it was, will have its own benefits and costs, and it might even contribute as a whole to the overall improvement of the solution&#039;s design.  If your refactoring was naive, such as in the dangerous case of simply removing the symptoms of a LoM violation, there really is no improvement in quality and, in fact, only more potential maintenance and mystery has been created.

As you mentioned in your post, you derived the extension method for DRY principles.  The extension method itself may or may not violate LoM, but it was still a good refactoring for both LoM and DRY purposes.  If the extension method is using an unchangeable archaic piece of some framework (even .NET), it might reasonably use more than one &quot;.&quot; in some member accesses or make vast assumptions about types in casting, where creating an extra-special class to remove this appearance within the extension method had no other obvious use within the system.  In other words, violating the &quot;Principle of Demeter&quot; might be a good idea to achieve more important broader system goals, but the violations might should be moved into special places, like extension methods or utility classes that have single self-describing responsibilities.

Anyway, sorry for beating this one to death -- just hope my two cents adds some clarity for someone.  I also welcome any suggested adjustment in my perception.</description>
		<content:encoded><![CDATA[<p>As Nolan pretty much said, LoM is more of a principle than a law, and the crux of the principle is what needs to be focused on and not the syntactic evidence of its application (or lack thereof).  With this understanding, I would no longer call extension methods, particularly those of the LINQ variety, simple syntactic sugar.</p>
<p>You can refactor any LoM violating line of code into something that doesn&#8217;t appear to violate LoM, by extracting a method or, more-so, a helper class.  Your refactoring, depending on what it was, will have its own benefits and costs, and it might even contribute as a whole to the overall improvement of the solution&#8217;s design.  If your refactoring was naive, such as in the dangerous case of simply removing the symptoms of a LoM violation, there really is no improvement in quality and, in fact, only more potential maintenance and mystery has been created.</p>
<p>As you mentioned in your post, you derived the extension method for DRY principles.  The extension method itself may or may not violate LoM, but it was still a good refactoring for both LoM and DRY purposes.  If the extension method is using an unchangeable archaic piece of some framework (even .NET), it might reasonably use more than one &#8220;.&#8221; in some member accesses or make vast assumptions about types in casting, where creating an extra-special class to remove this appearance within the extension method had no other obvious use within the system.  In other words, violating the &#8220;Principle of Demeter&#8221; might be a good idea to achieve more important broader system goals, but the violations might should be moved into special places, like extension methods or utility classes that have single self-describing responsibilities.</p>
<p>Anyway, sorry for beating this one to death &#8212; just hope my two cents adds some clarity for someone.  I also welcome any suggested adjustment in my perception.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Derek Greer</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-708</link>
		<dc:creator>Derek Greer</dc:creator>
		<pubDate>Thu, 25 Mar 2010 15:32:22 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-708</guid>
		<description>Extensions methods aren&#039;t somehow excluded from the restrictions imposed by the Law of Demeter because they appear to be methods of the extended class, but the particular example presented here isn&#039;t a violation since the get_Count() method (i.e. the Count property) is a method of Asset which is a parameter to the As() method.  Were an extension method to execute a method of a property of one its parameters then it could be a violation depending on the instance type (i.e. ExtensionMethod() -&gt; Parameter.Property.Method()).</description>
		<content:encoded><![CDATA[<p>Extensions methods aren&#8217;t somehow excluded from the restrictions imposed by the Law of Demeter because they appear to be methods of the extended class, but the particular example presented here isn&#8217;t a violation since the get_Count() method (i.e. the Count property) is a method of Asset which is a parameter to the As() method.  Were an extension method to execute a method of a property of one its parameters then it could be a violation depending on the instance type (i.e. ExtensionMethod() -> Parameter.Property.Method()).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Derek Hammer</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-707</link>
		<dc:creator>Derek Hammer</dc:creator>
		<pubDate>Thu, 25 Mar 2010 15:23:35 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-707</guid>
		<description>If you are counting dots, you&#039;re doing it wrong.</description>
		<content:encoded><![CDATA[<p>If you are counting dots, you&#8217;re doing it wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nathan Evans</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-706</link>
		<dc:creator>Nathan Evans</dc:creator>
		<pubDate>Thu, 25 Mar 2010 15:10:39 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-706</guid>
		<description>Extension methods are good refactoring candidates at a later stage as well. I&#039;d much rather refactor a single one of those than refactoring a ton of foreach loops and what not.

I would agree that extension methods are a very special case and are exempt from demeter law.</description>
		<content:encoded><![CDATA[<p>Extension methods are good refactoring candidates at a later stage as well. I&#8217;d much rather refactor a single one of those than refactoring a ton of foreach loops and what not.</p>
<p>I would agree that extension methods are a very special case and are exempt from demeter law.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jason Smith</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-705</link>
		<dc:creator>Jason Smith</dc:creator>
		<pubDate>Thu, 25 Mar 2010 15:02:47 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-705</guid>
		<description>I wouldn&#039;t go so far as to exempt extension methods from the Law of Demeter (LoD).  

As Phil Haack once wrote, &lt;a href=&quot;http://haacked.com/archive/2009/07/14/law-of-demeter-dot-counting.aspx&quot;&gt;the Law of Demeter is not a Dot Counting Excersize&lt;/a&gt;.  It&#039;s about controlling how many &lt;em&gt;dependencies&lt;/em&gt; you force code to have.   

In this example, we simply don&#039;t know enough about the context to say whether it does or does not violate the law (shamelessly lifted from Wikipedia):

M of an object O may only invoke the methods of the following kinds of objects:

   1. O itself
   2. M&#039;s parameters
   3. any objects created/instantiated within M
   4. O&#039;s direct component objects
   5. a global variable, accessible by O, in the scope of M

</description>
		<content:encoded><![CDATA[<p>I wouldn&#8217;t go so far as to exempt extension methods from the Law of Demeter (LoD).  </p>
<p>As Phil Haack once wrote, <a href="http://haacked.com/archive/2009/07/14/law-of-demeter-dot-counting.aspx">the Law of Demeter is not a Dot Counting Excersize</a>.  It&#8217;s about controlling how many <em>dependencies</em> you force code to have.   </p>
<p>In this example, we simply don&#8217;t know enough about the context to say whether it does or does not violate the law (shamelessly lifted from Wikipedia):</p>
<p>M of an object O may only invoke the methods of the following kinds of objects:</p>
<p>   1. O itself<br />
   2. M&#8217;s parameters<br />
   3. any objects created/instantiated within M<br />
   4. O&#8217;s direct component objects<br />
   5. a global variable, accessible by O, in the scope of M</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: bogardj</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-704</link>
		<dc:creator>bogardj</dc:creator>
		<pubDate>Thu, 25 Mar 2010 14:53:33 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-704</guid>
		<description>Isn&#039;t this a LSV violation, with the down-casting?  Then you have the check to see if a collection is null. Collections should never be null, but just in case, I also have a IsNullOrEmpty() extension method:

return sequence == null &amp;&amp; !sequence.Any();

If you want the first item of a certain type, I&#039;d do sequency.OfType&lt;Foo&gt;().FirstOrDefault();</description>
		<content:encoded><![CDATA[<p>Isn&#8217;t this a LSV violation, with the down-casting?  Then you have the check to see if a collection is null. Collections should never be null, but just in case, I also have a IsNullOrEmpty() extension method:</p>
<p>return sequence == null &#038;&#038; !sequence.Any();</p>
<p>If you want the first item of a certain type, I&#8217;d do sequency.OfType<foo>().FirstOrDefault();</foo></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nolan Egly</title>
		<link>http://lostechies.com/derickbailey/2010/03/25/law-of-demeter-extension-methods-don-t-count/#comment-703</link>
		<dc:creator>Nolan Egly</dc:creator>
		<pubDate>Thu, 25 Mar 2010 14:38:32 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2010/03/25/law-of-demeter-extension-methods-don-t-count.aspx#comment-703</guid>
		<description>I tend to think of it as the &quot;suggestion of Demeter&quot;, because sometimes there are good reasons to &quot;violate&quot; it, and I agree with you that extension methods are a good example.

The purpose of Demeter is to prevent outside objects from having too much knowledge and reliance on the behavior of objects contained within other objects.  This makes clear division of responsibilities (not to mention refactoring) difficult.

E.g., object foo contains object bar.  Object baz should not invoke Foo.Bar.DoSomething().  In my opinion, it IS ok for baz to reference Foo.Bar.DataProperty when foo has some public composite data (otherwise you end up doing a lot of work to have all properties directly on foo, just to avoid calling Foo.Bar.SomeProperty).  Or in your example here, call some static extension methods.

Unfortunately, when you simplify Demeter from &quot;don&#039;t rely on behavior on internals of other objects&quot; to &quot;don&#039;t use more than one dot&quot;, you lose this critical thinking on context.</description>
		<content:encoded><![CDATA[<p>I tend to think of it as the &#8220;suggestion of Demeter&#8221;, because sometimes there are good reasons to &#8220;violate&#8221; it, and I agree with you that extension methods are a good example.</p>
<p>The purpose of Demeter is to prevent outside objects from having too much knowledge and reliance on the behavior of objects contained within other objects.  This makes clear division of responsibilities (not to mention refactoring) difficult.</p>
<p>E.g., object foo contains object bar.  Object baz should not invoke Foo.Bar.DoSomething().  In my opinion, it IS ok for baz to reference Foo.Bar.DataProperty when foo has some public composite data (otherwise you end up doing a lot of work to have all properties directly on foo, just to avoid calling Foo.Bar.SomeProperty).  Or in your example here, call some static extension methods.</p>
<p>Unfortunately, when you simplify Demeter from &#8220;don&#8217;t rely on behavior on internals of other objects&#8221; to &#8220;don&#8217;t use more than one dot&#8221;, you lose this critical thinking on context.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Performance optimized by W3 Total Cache. Learn more: http://www.w3-edge.com/wordpress-plugins/

Page Caching using disk: enhanced

Served from: lostechies.com @ 2013-01-15 15:37:29 -->