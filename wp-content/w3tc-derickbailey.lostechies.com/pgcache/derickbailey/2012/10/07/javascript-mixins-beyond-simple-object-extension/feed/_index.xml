<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments on: JavaScript Mixins: Beyond Simple Object Extension</title>
	<atom:link href="http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/feed/" rel="self" type="application/rss+xml" />
	<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/</link>
	<description>Better Than Yesterday</description>
	<lastBuildDate>Sun, 16 Dec 2012 23:48:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.2</generator>
	<item>
		<title>By: Sara Lisa</title>
		<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/#comment-2858</link>
		<dc:creator>Sara Lisa</dc:creator>
		<pubDate>Tue, 27 Nov 2012 09:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://lostechies.com/derickbailey/?p=1009#comment-2858</guid>
		<description>Hi Bailey! this was unique. the logic used really helped me in many ways. there is always a challenging life for programmers. thanks &lt;a href=&quot;http://www.a2zonlinetraining.com/datawarehousing-online-training/business-objects-online-training.php&quot; rel=&quot;nofollow&quot;&gt;Business Objects Online Training&lt;/a&gt;</description>
		<content:encoded><![CDATA[<p>Hi Bailey! this was unique. the logic used really helped me in many ways. there is always a challenging life for programmers. thanks <a href="http://www.a2zonlinetraining.com/datawarehousing-online-training/business-objects-online-training.php" rel="nofollow">Business Objects Online Training</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Derick Bailey</title>
		<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/#comment-2804</link>
		<dc:creator>Derick Bailey</dc:creator>
		<pubDate>Fri, 26 Oct 2012 01:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://lostechies.com/derickbailey/?p=1009#comment-2804</guid>
		<description>correct on all counts. :)


this was a very naive implementation, meant to be an illustration of an idea, and not really production ready code.


regarding the need to access the target object from the mixin - yeah, this has been the largest problem i&#039;ve encountered in trying out these ideas in real code. i have some ideas for getting around that, but it all involves more code than i like.


i think there&#039;s value in this idea, still. but it will need to be fleshed out in to something that is easy to use and provides real value without a lot of overhead.</description>
		<content:encoded><![CDATA[<p>correct on all counts. :)</p>
<p>this was a very naive implementation, meant to be an illustration of an idea, and not really production ready code.</p>
<p>regarding the need to access the target object from the mixin &#8211; yeah, this has been the largest problem i&#8217;ve encountered in trying out these ideas in real code. i have some ideas for getting around that, but it all involves more code than i like.</p>
<p>i think there&#8217;s value in this idea, still. but it will need to be fleshed out in to something that is easy to use and provides real value without a lot of overhead.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kevin</title>
		<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/#comment-2802</link>
		<dc:creator>Kevin</dc:creator>
		<pubDate>Thu, 25 Oct 2012 22:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://lostechies.com/derickbailey/?p=1009#comment-2802</guid>
		<description>Derick, 

Interesting post, thanks. It seems like the approach here is to only mix in public methods, and if there is internal state that needs to be maintained, that they not be maintained on the target class. Seems like a good idea, so that you can avoid conflicts on the target class.  Although doing this by manipulating the function&#039;s context does prevent your mixin functions from using other functionality on the target class, although maybe this is intentional?

And if I&#039;m reading it correctly, your first implementation here would pollute the source mixin object:

	//Dummy mixin implementation

	var CoolMixin = {

	  bindTo: function(args) {

	    this._bindings &#124;&#124; (this._bindings = []);

		this._bindings.push(args);

	  },

	  getBindings: function() {

	  	return this._bindings;

	  }

	};

	var A = new Backbone.View({});

	var B = new Backbone.View({});

	mixInto(A, CoolMixin, &#039;bindTo&#039;, &#039;getBindings&#039;);

	mixInto(B, CoolMixin, &#039;bindTo&#039;, &#039;getBindings&#039;);

	//Now let&#039;s bind A and B to events on C

	var C = new Backbone.Model({});

	//This has the effect of applying CoolMixin#bindTo in the context of CoolMixin, thus adding a _bindings property to CoolMixin.

	A.bindTo(C, &#039;change&#039;, A.render);

	//And since the CoolMixin methods on B are also bound to the same source, B now has A&#039;s bindings.

	console.log(B.getBindings());

	//And if we bind B to another event, A gets them as well

	B.bindTo(C, &#039;change&#039;, B.render);

	console.log(A.getBindings());

And I believe the second implementation of mixInto is missing a return statement near the end and should read:

   return source[method].apply(source, args);

If you&#039;re trying to avoid maintaining state on the target object, you lose the simplicity of the object literal literally getting mixed in.  At that point you may as well just make another standalone object to track the mixin&#039;s state.  This is something we&#039;ve done in similar circumstances when there&#039;s a lot of state to track, and I think is similar to your approach with the EventBinder, except it explicitly passes the state object instead of passing it through the function context.  With this approach, you have a plain object literal mixin that mixes in some sort of initialization method onto the target class, and that initialization method creates a separate object to manage any state that the mixin needs to maintain, as well as mixes in any additional functionality.  This approach also lets you be really careful (if you want to be) and even add a check at runtime for whether the mixin would overwrite an existing method.  Like this:

	//Utility function for getting all properties on an object, including ones set on its prototype chain

  	var allKeys = function(obj) {

  		var keys = [];

  		for (var prop in obj) { keys.push(prop); }

  		return keys;

  	};

	//Dummy mixin implementation

	var CoolMixinLazy = {

	  initCoolMixin: function() {

	    //Mixin state gets closed over here

	    //You can imagine this using a whole other object rather than just an array if needed.

	  	var bindings = [];

		var methods = {

		  bindTo: function(args) {

		    bindings.push(args);

		  },

		  getBindings: function() {

		  	return bindings;

		  }

	  	};

	  	//Optional run time check for collisions, or possibly chaining

	  	//methods together (e.g., Backbone.Model#validate)

	  	var collisions = _.intersect(_.keys(methods), allKeys(this));

	  	console.log(_.keys(methods), _.keys(this), collisions);

	  	if (!_.isEmpty(collisions)) throw new Error(&#039;collision trying to mix in: &#039; + collisions.join(&#039;, &#039;));

	  	//Mix in and return this for chaining

	  	_.extend(this, methods);

	  	return this;

	  }

	};

	var LazyView = Backbone.View.extend(CoolMixinLazy);

    var D = new LazyView({});

    D.initCoolMixin();

    //detecting collisions

    var DifferentView = Backbone.View.extend({ getBindings: &#039;there are none!&#039; });

    var LazyDifferentView = DifferentView.extend(CoolMixinLazy);

    var E = new LazyDifferentView({});

    E.initCoolMixin();

Personally, almost all of this is overkill for me, which is why I mostly keep using the object literal approach and storing any object state on the target object, just with weirder names than _bindings.  Maybe not the best long term strategy, but seems the simplest to me for the moment.  :)

-Kevin</description>
		<content:encoded><![CDATA[<p>Derick, </p>
<p>Interesting post, thanks. It seems like the approach here is to only mix in public methods, and if there is internal state that needs to be maintained, that they not be maintained on the target class. Seems like a good idea, so that you can avoid conflicts on the target class.  Although doing this by manipulating the function&#8217;s context does prevent your mixin functions from using other functionality on the target class, although maybe this is intentional?</p>
<p>And if I&#8217;m reading it correctly, your first implementation here would pollute the source mixin object:</p>
<p>	//Dummy mixin implementation</p>
<p>	var CoolMixin = {</p>
<p>	  bindTo: function(args) {</p>
<p>	    this._bindings || (this._bindings = []);</p>
<p>		this._bindings.push(args);</p>
<p>	  },</p>
<p>	  getBindings: function() {</p>
<p>	  	return this._bindings;</p>
<p>	  }</p>
<p>	};</p>
<p>	var A = new Backbone.View({});</p>
<p>	var B = new Backbone.View({});</p>
<p>	mixInto(A, CoolMixin, &#8216;bindTo&#8217;, &#8216;getBindings&#8217;);</p>
<p>	mixInto(B, CoolMixin, &#8216;bindTo&#8217;, &#8216;getBindings&#8217;);</p>
<p>	//Now let&#8217;s bind A and B to events on C</p>
<p>	var C = new Backbone.Model({});</p>
<p>	//This has the effect of applying CoolMixin#bindTo in the context of CoolMixin, thus adding a _bindings property to CoolMixin.</p>
<p>	A.bindTo(C, &#8216;change&#8217;, A.render);</p>
<p>	//And since the CoolMixin methods on B are also bound to the same source, B now has A&#8217;s bindings.</p>
<p>	console.log(B.getBindings());</p>
<p>	//And if we bind B to another event, A gets them as well</p>
<p>	B.bindTo(C, &#8216;change&#8217;, B.render);</p>
<p>	console.log(A.getBindings());</p>
<p>And I believe the second implementation of mixInto is missing a return statement near the end and should read:</p>
<p>   return source[method].apply(source, args);</p>
<p>If you&#8217;re trying to avoid maintaining state on the target object, you lose the simplicity of the object literal literally getting mixed in.  At that point you may as well just make another standalone object to track the mixin&#8217;s state.  This is something we&#8217;ve done in similar circumstances when there&#8217;s a lot of state to track, and I think is similar to your approach with the EventBinder, except it explicitly passes the state object instead of passing it through the function context.  With this approach, you have a plain object literal mixin that mixes in some sort of initialization method onto the target class, and that initialization method creates a separate object to manage any state that the mixin needs to maintain, as well as mixes in any additional functionality.  This approach also lets you be really careful (if you want to be) and even add a check at runtime for whether the mixin would overwrite an existing method.  Like this:</p>
<p>	//Utility function for getting all properties on an object, including ones set on its prototype chain</p>
<p>  	var allKeys = function(obj) {</p>
<p>  		var keys = [];</p>
<p>  		for (var prop in obj) { keys.push(prop); }</p>
<p>  		return keys;</p>
<p>  	};</p>
<p>	//Dummy mixin implementation</p>
<p>	var CoolMixinLazy = {</p>
<p>	  initCoolMixin: function() {</p>
<p>	    //Mixin state gets closed over here</p>
<p>	    //You can imagine this using a whole other object rather than just an array if needed.</p>
<p>	  	var bindings = [];</p>
<p>		var methods = {</p>
<p>		  bindTo: function(args) {</p>
<p>		    bindings.push(args);</p>
<p>		  },</p>
<p>		  getBindings: function() {</p>
<p>		  	return bindings;</p>
<p>		  }</p>
<p>	  	};</p>
<p>	  	//Optional run time check for collisions, or possibly chaining</p>
<p>	  	//methods together (e.g., Backbone.Model#validate)</p>
<p>	  	var collisions = _.intersect(_.keys(methods), allKeys(this));</p>
<p>	  	console.log(_.keys(methods), _.keys(this), collisions);</p>
<p>	  	if (!_.isEmpty(collisions)) throw new Error(&#8216;collision trying to mix in: &#8216; + collisions.join(&#8216;, &#8216;));</p>
<p>	  	//Mix in and return this for chaining</p>
<p>	  	_.extend(this, methods);</p>
<p>	  	return this;</p>
<p>	  }</p>
<p>	};</p>
<p>	var LazyView = Backbone.View.extend(CoolMixinLazy);</p>
<p>    var D = new LazyView({});</p>
<p>    D.initCoolMixin();</p>
<p>    //detecting collisions</p>
<p>    var DifferentView = Backbone.View.extend({ getBindings: &#8216;there are none!&#8217; });</p>
<p>    var LazyDifferentView = DifferentView.extend(CoolMixinLazy);</p>
<p>    var E = new LazyDifferentView({});</p>
<p>    E.initCoolMixin();</p>
<p>Personally, almost all of this is overkill for me, which is why I mostly keep using the object literal approach and storing any object state on the target object, just with weirder names than _bindings.  Maybe not the best long term strategy, but seems the simplest to me for the moment.  :)</p>
<p>-Kevin</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kevin</title>
		<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/#comment-2803</link>
		<dc:creator>Kevin</dc:creator>
		<pubDate>Thu, 25 Oct 2012 22:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://lostechies.com/derickbailey/?p=1009#comment-2803</guid>
		<description>Sorry about the formatting...</description>
		<content:encoded><![CDATA[<p>Sorry about the formatting&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Pedro Solá</title>
		<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/#comment-2800</link>
		<dc:creator>Pedro Solá</dc:creator>
		<pubDate>Tue, 23 Oct 2012 00:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://lostechies.com/derickbailey/?p=1009#comment-2800</guid>
		<description>I think you&#039;ve misunderstood the whole point context binding.

If you pluck a function from another object and maintain it&#039;s original context, you&#039;re just creating an alias. Not terribly useful, it&#039;s just syntax suger. 


The interesting thing is usually to pluck a function from an object, and bind it to another. 


For example, (and this is specifically the use-case you discourage) a jQuery callback.
How do do imagine Backbone&#039;s declarative events get bound to the view? 

$(this.el).on(&#039;click&#039;, &#039;.delete&#039;, _.bind(this, someObject,clickhandler)); 


so clickHander can call this.model.delete(), for example. 


Have you even read the source of underscore&#039;s bind method? It&#039;s like 10 lines. Not complicated at all. 



No offense, but this article is spreading some serious mis-information. I feel should warn those unfamiliar with the subject to do make sure they get their facts straight.</description>
		<content:encoded><![CDATA[<p>I think you&#8217;ve misunderstood the whole point context binding.</p>
<p>If you pluck a function from another object and maintain it&#8217;s original context, you&#8217;re just creating an alias. Not terribly useful, it&#8217;s just syntax suger. </p>
<p>The interesting thing is usually to pluck a function from an object, and bind it to another. </p>
<p>For example, (and this is specifically the use-case you discourage) a jQuery callback.<br />
How do do imagine Backbone&#8217;s declarative events get bound to the view? </p>
<p>$(this.el).on(&#8216;click&#8217;, &#8216;.delete&#8217;, _.bind(this, someObject,clickhandler)); </p>
<p>so clickHander can call this.model.delete(), for example. </p>
<p>Have you even read the source of underscore&#8217;s bind method? It&#8217;s like 10 lines. Not complicated at all. </p>
<p>No offense, but this article is spreading some serious mis-information. I feel should warn those unfamiliar with the subject to do make sure they get their facts straight.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ruben Vreeken</title>
		<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/#comment-2799</link>
		<dc:creator>Ruben Vreeken</dc:creator>
		<pubDate>Mon, 22 Oct 2012 13:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://lostechies.com/derickbailey/?p=1009#comment-2799</guid>
		<description>I think in some cases this could also be interesting in combination with a facade. Lets say your component is actually always intended to be a mixin.


You could expose the methods you want to mix into the target through the facade and keep the things you don&#039;t want to mix in private. 


That way the component is in control of which methods get mixed in, rather then requiring a developer to manage this manually.</description>
		<content:encoded><![CDATA[<p>I think in some cases this could also be interesting in combination with a facade. Lets say your component is actually always intended to be a mixin.</p>
<p>You could expose the methods you want to mix into the target through the facade and keep the things you don&#8217;t want to mix in private. </p>
<p>That way the component is in control of which methods get mixed in, rather then requiring a developer to manage this manually.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Eric Elliott</title>
		<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/#comment-2780</link>
		<dc:creator>Eric Elliott</dc:creator>
		<pubDate>Thu, 11 Oct 2012 22:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://lostechies.com/derickbailey/?p=1009#comment-2780</guid>
		<description>Nice work on this. I use a similar technique in applitude.js to allow users to trigger events on a global eventEmitter using shortcuts on the app object: app.on() maps to app.events.on(), etc... I really like your closure implementation of mixInto().

http://ericleads.com/2012/08/introducing-applitude-simple-module-management/
</description>
		<content:encoded><![CDATA[<p>Nice work on this. I use a similar technique in applitude.js to allow users to trigger events on a global eventEmitter using shortcuts on the app object: app.on() maps to app.events.on(), etc&#8230; I really like your closure implementation of mixInto().</p>
<p><a href="http://ericleads.com/2012/08/introducing-applitude-simple-module-management/" rel="nofollow">http://ericleads.com/2012/08/introducing-applitude-simple-module-management/</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Trisha Sue</title>
		<link>http://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/#comment-2773</link>
		<dc:creator>Trisha Sue</dc:creator>
		<pubDate>Tue, 09 Oct 2012 17:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://lostechies.com/derickbailey/?p=1009#comment-2773</guid>
		<description>Thanks for this post.  It made me understand JavaScript ixins a lot better.</description>
		<content:encoded><![CDATA[<p>Thanks for this post.  It made me understand JavaScript ixins a lot better.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Performance optimized by W3 Total Cache. Learn more: http://www.w3-edge.com/wordpress-plugins/

Page Caching using disk: enhanced

Served from: lostechies.com @ 2012-12-19 05:30:33 -->