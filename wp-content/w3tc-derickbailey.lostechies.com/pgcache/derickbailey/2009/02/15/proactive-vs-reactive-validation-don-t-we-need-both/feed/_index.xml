<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments on: Proactive vs Reactive Validation: Don’t We Need Both?</title>
	<atom:link href="http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/feed/" rel="self" type="application/rss+xml" />
	<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/</link>
	<description>Better Than Yesterday</description>
	<lastBuildDate>Mon, 05 Nov 2012 04:46:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.2</generator>
	<item>
		<title>By: derick.bailey</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-168</link>
		<dc:creator>derick.bailey</dc:creator>
		<pubDate>Mon, 16 Feb 2009 17:58:33 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-168</guid>
		<description>@jonothan

I&#039;m reading your posts now. thanks!</description>
		<content:encoded><![CDATA[<p>@jonothan</p>
<p>I&#8217;m reading your posts now. thanks!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jonathan</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-167</link>
		<dc:creator>Jonathan</dc:creator>
		<pubDate>Mon, 16 Feb 2009 17:29:23 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-167</guid>
		<description>Thanks for posting on this.  This has been a difficult point for our team as well.  As you have pointed out in one of your comments, Jimmy&#039;s post really cleared stuff up.  I wanted to point out that Jimmy&#039;s post is just the beginning.  Performing proper validation seems to point towards Command/Query Separation.  Greg Young of CodeBetter has a highly informative InfoQ video on doing CQS—which he doesn’t relate directly to validation, but with Jimmy Bogard’s post, the two can be tied together nicely.  In other words, watch the video and then read Jimmy’s post again.  Also, take a look at my two most recent blog posts—I discuss the matter in more depth.</description>
		<content:encoded><![CDATA[<p>Thanks for posting on this.  This has been a difficult point for our team as well.  As you have pointed out in one of your comments, Jimmy&#8217;s post really cleared stuff up.  I wanted to point out that Jimmy&#8217;s post is just the beginning.  Performing proper validation seems to point towards Command/Query Separation.  Greg Young of CodeBetter has a highly informative InfoQ video on doing CQS—which he doesn’t relate directly to validation, but with Jimmy Bogard’s post, the two can be tied together nicely.  In other words, watch the video and then read Jimmy’s post again.  Also, take a look at my two most recent blog posts—I discuss the matter in more depth.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jordan Terrell</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-166</link>
		<dc:creator>Jordan Terrell</dc:creator>
		<pubDate>Mon, 16 Feb 2009 16:40:38 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-166</guid>
		<description>Take a look at the Essense pattern (some would argue that it is a modified Memento pattern).  This might allow you to do reactive validation in the Essense class (i.e. collect data one field at a time), and still allow proactive validation in the Entity itself.  Just a thought...

http://jerry.cs.uiuc.edu/~plop/plop98/final_submissions/P10.pdf
http://www.codeproject.com/KB/architecture/essencepattern.aspx</description>
		<content:encoded><![CDATA[<p>Take a look at the Essense pattern (some would argue that it is a modified Memento pattern).  This might allow you to do reactive validation in the Essense class (i.e. collect data one field at a time), and still allow proactive validation in the Entity itself.  Just a thought&#8230;</p>
<p><a href="http://jerry.cs.uiuc.edu/~plop/plop98/final_submissions/P10.pdf" rel="nofollow">http://jerry.cs.uiuc.edu/~plop/plop98/final_submissions/P10.pdf</a><br />
<a href="http://www.codeproject.com/KB/architecture/essencepattern.aspx" rel="nofollow">http://www.codeproject.com/KB/architecture/essencepattern.aspx</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: derick.bailey</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-165</link>
		<dc:creator>derick.bailey</dc:creator>
		<pubDate>Mon, 16 Feb 2009 15:46:57 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-165</guid>
		<description>Sean and I continue the conversation via our internal instant messenger client today. Just wanted to share with the rest of you. I&#039;ve re-ordered some of the messages so they make more sense.

Sean Biefeld:
  why not come up with a way to avoid doing the isvalid, cansave check, not worry if entity is valid, know if it exists it is valid

Derick E. Bailey:
  because it&#039;s not possible to do that.

Sean Biefeld :
  well it should be

Derick E. Bailey:
  by your own statement &quot;know if it exists, it is valid&quot;, you&#039;ve already stated that validation has happened
  it just happened at construction
  the real problem with this, in c#, is that we can&#039;t &quot;cancel&quot; object construction without throwing exceptions

Derick E. Bailey:
  you can&#039;t return null from a constructor
  i agree with that idea, but i think there&#039;s a little more to it than just that
  that idea of &quot;valid&quot; is context dependent
  whether you are creating a new object for &quot;SignedDrugOrder&quot; vs &quot;DrugOrderRequest&quot;, or using a state pattern or isvalid flags - you are still doing the validation
  it&#039;s just context specific validation
  you are validating that the drug order is signed by creating a &quot;signeddrugorder&quot; instance

Sean Biefeld:
  ideally in my perfect world no object would exist that is invalid

Sean Biefeld:
  im not saying there is no need for context

Derick E. Bailey:
  it is context dependent - but implemented in a manner that is specifically suited to creating only valid entities. i love that idea.
  i think there&#039;s a lot of great uses for that
  it always comes back to &#039;what does this specific system need&#039;

Sean Biefeld:
  ya im trying not to think about it in a specific instance, but in ideal terms
  so i can work down to a specific instance with specific needs

Derick E. Bailey:
  ya. the ideal world is always different than what we can actually do. i think we really do have the same general view on this...

Derick E. Bailey:
  right
  good distinction to make

Derick E. Bailey:
  quite honestly, i&#039;m probably very wrong in my opinions about what you can and can&#039;t do, or should and shouldn&#039;t do. maybe it&#039;s not too much to ask for &quot;if an object is created, it&#039;s valid&quot;.
  having people that are willing to challenge my assumptions forces me to re-think my own assumptions and see if there really is a better way

Sean Biefeld:
  ya it all comes down to implementation and what is needed, and the capabilities of the language in use
</description>
		<content:encoded><![CDATA[<p>Sean and I continue the conversation via our internal instant messenger client today. Just wanted to share with the rest of you. I&#8217;ve re-ordered some of the messages so they make more sense.</p>
<p>Sean Biefeld:<br />
  why not come up with a way to avoid doing the isvalid, cansave check, not worry if entity is valid, know if it exists it is valid</p>
<p>Derick E. Bailey:<br />
  because it&#8217;s not possible to do that.</p>
<p>Sean Biefeld :<br />
  well it should be</p>
<p>Derick E. Bailey:<br />
  by your own statement &#8220;know if it exists, it is valid&#8221;, you&#8217;ve already stated that validation has happened<br />
  it just happened at construction<br />
  the real problem with this, in c#, is that we can&#8217;t &#8220;cancel&#8221; object construction without throwing exceptions</p>
<p>Derick E. Bailey:<br />
  you can&#8217;t return null from a constructor<br />
  i agree with that idea, but i think there&#8217;s a little more to it than just that<br />
  that idea of &#8220;valid&#8221; is context dependent<br />
  whether you are creating a new object for &#8220;SignedDrugOrder&#8221; vs &#8220;DrugOrderRequest&#8221;, or using a state pattern or isvalid flags &#8211; you are still doing the validation<br />
  it&#8217;s just context specific validation<br />
  you are validating that the drug order is signed by creating a &#8220;signeddrugorder&#8221; instance</p>
<p>Sean Biefeld:<br />
  ideally in my perfect world no object would exist that is invalid</p>
<p>Sean Biefeld:<br />
  im not saying there is no need for context</p>
<p>Derick E. Bailey:<br />
  it is context dependent &#8211; but implemented in a manner that is specifically suited to creating only valid entities. i love that idea.<br />
  i think there&#8217;s a lot of great uses for that<br />
  it always comes back to &#8216;what does this specific system need&#8217;</p>
<p>Sean Biefeld:<br />
  ya im trying not to think about it in a specific instance, but in ideal terms<br />
  so i can work down to a specific instance with specific needs</p>
<p>Derick E. Bailey:<br />
  ya. the ideal world is always different than what we can actually do. i think we really do have the same general view on this&#8230;</p>
<p>Derick E. Bailey:<br />
  right<br />
  good distinction to make</p>
<p>Derick E. Bailey:<br />
  quite honestly, i&#8217;m probably very wrong in my opinions about what you can and can&#8217;t do, or should and shouldn&#8217;t do. maybe it&#8217;s not too much to ask for &#8220;if an object is created, it&#8217;s valid&#8221;.<br />
  having people that are willing to challenge my assumptions forces me to re-think my own assumptions and see if there really is a better way</p>
<p>Sean Biefeld:<br />
  ya it all comes down to implementation and what is needed, and the capabilities of the language in use</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: derick.bailey</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-164</link>
		<dc:creator>derick.bailey</dc:creator>
		<pubDate>Mon, 16 Feb 2009 13:58:19 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-164</guid>
		<description>@all,

Thank you all very much for your comments on these questions... in combination with Jimmy&#039;s post (http://www.lostechies.com/blogs/jimmy_bogard/archive/2009/02/15/validation-in-a-ddd-world.aspx) I think I have a better idea of what I should be looking for / doing in my systems. As it turns out, I may have been going down &#039;the right path&#039; already with my recent code. It&#039;s always nice to be validated, though (punny, yes? :P )
</description>
		<content:encoded><![CDATA[<p>@all,</p>
<p>Thank you all very much for your comments on these questions&#8230; in combination with Jimmy&#8217;s post (<a href="http://www.lostechies.com/blogs/jimmy_bogard/archive/2009/02/15/validation-in-a-ddd-world.aspx" rel="nofollow">http://www.lostechies.com/blogs/jimmy_bogard/archive/2009/02/15/validation-in-a-ddd-world.aspx</a>) I think I have a better idea of what I should be looking for / doing in my systems. As it turns out, I may have been going down &#8216;the right path&#8217; already with my recent code. It&#8217;s always nice to be validated, though (punny, yes? :P )</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Lars M&#230;hlum</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-163</link>
		<dc:creator>Lars M&#230;hlum</dc:creator>
		<pubDate>Mon, 16 Feb 2009 07:57:18 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-163</guid>
		<description>If you truly want to go far out on this one, why not use an Aspect Oriented approach to validation?
If you make your DTO&#039;s with validation attributes, you can easily tack on field validation logic in the View, while demanding that the mapping to your domain objects also validation the whole object before it is mapped.
This way your domain objects stay clean, while you can ensure that all objects passing the DTO-DMO barrier are valid.

Just my $.02
:)</description>
		<content:encoded><![CDATA[<p>If you truly want to go far out on this one, why not use an Aspect Oriented approach to validation?<br />
If you make your DTO&#8217;s with validation attributes, you can easily tack on field validation logic in the View, while demanding that the mapping to your domain objects also validation the whole object before it is mapped.<br />
This way your domain objects stay clean, while you can ensure that all objects passing the DTO-DMO barrier are valid.</p>
<p>Just my $.02<br />
:)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: nightshade427</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-162</link>
		<dc:creator>nightshade427</dc:creator>
		<pubDate>Mon, 16 Feb 2009 02:37:12 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-162</guid>
		<description>Don’t bind your entities directly to the UI it makes life hard, use a UI model.

Not all validation needs to go into the Entity. You have to think if the validation applies to entity in all cases. If so then by all means put it into the entity. If it is more related to how an entity is used in a service of some kind, then put it in the service. If it has more to do with how an entity relates to something else put it into a relational object of some kind. I guess what I am getting at is look at how the validation is used and when it applies and put it in the correct place to handle that.</description>
		<content:encoded><![CDATA[<p>Don’t bind your entities directly to the UI it makes life hard, use a UI model.</p>
<p>Not all validation needs to go into the Entity. You have to think if the validation applies to entity in all cases. If so then by all means put it into the entity. If it is more related to how an entity is used in a service of some kind, then put it in the service. If it has more to do with how an entity relates to something else put it into a relational object of some kind. I guess what I am getting at is look at how the validation is used and when it applies and put it in the correct place to handle that.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Scott Bellware</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-161</link>
		<dc:creator>Scott Bellware</dc:creator>
		<pubDate>Sun, 15 Feb 2009 22:12:23 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-161</guid>
		<description>The problem is that you&#039;re looking for a consistent theory or guideline that crosses applications and technologies.  Not only does it not exist, but it doesn&#039;t exist because it&#039;s not necessary.

The here is with DDD-light - when we think of our solutions in terms of concrete &quot;Domain Entities&quot; and &quot;Services&quot; and &quot;Repositories&quot; and &quot;Specifications&quot; and &quot;Value Objects&quot;.  Programmers got a hold of these things and turned them into programmer artifacts.  Got a namespace called &quot;Repositories&quot;?  You&#039;re in the ditch.  Got a namespace called &quot;Services&quot;?  You&#039;re in the ditch.

You need to do DDD as a domain-driven designer rather than a programmer.  This means backing off the unconscious and utterly unproductive behavioral habits of programmers who turn every concept into a heirarchy that can be represented in code. When you can see domain-driven design in your code, you&#039;re doing it naively, and that naivety means over-specialization and that means problems.

DDD isn&#039;t a guideline for coding.  It&#039;s a guideline for thinking.  You need more content in the cabeza before turning thoughts into code.  If you&#039;re thinking &quot;Entity&quot; or &quot;Repository&quot; and that&#039;s what ends up in the code, then there&#039;s a whole field of work and thinking that represents multiple steps of software work that are simply awol from the process.</description>
		<content:encoded><![CDATA[<p>The problem is that you&#8217;re looking for a consistent theory or guideline that crosses applications and technologies.  Not only does it not exist, but it doesn&#8217;t exist because it&#8217;s not necessary.</p>
<p>The here is with DDD-light &#8211; when we think of our solutions in terms of concrete &#8220;Domain Entities&#8221; and &#8220;Services&#8221; and &#8220;Repositories&#8221; and &#8220;Specifications&#8221; and &#8220;Value Objects&#8221;.  Programmers got a hold of these things and turned them into programmer artifacts.  Got a namespace called &#8220;Repositories&#8221;?  You&#8217;re in the ditch.  Got a namespace called &#8220;Services&#8221;?  You&#8217;re in the ditch.</p>
<p>You need to do DDD as a domain-driven designer rather than a programmer.  This means backing off the unconscious and utterly unproductive behavioral habits of programmers who turn every concept into a heirarchy that can be represented in code. When you can see domain-driven design in your code, you&#8217;re doing it naively, and that naivety means over-specialization and that means problems.</p>
<p>DDD isn&#8217;t a guideline for coding.  It&#8217;s a guideline for thinking.  You need more content in the cabeza before turning thoughts into code.  If you&#8217;re thinking &#8220;Entity&#8221; or &#8220;Repository&#8221; and that&#8217;s what ends up in the code, then there&#8217;s a whole field of work and thinking that represents multiple steps of software work that are simply awol from the process.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Eric Hauser</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-160</link>
		<dc:creator>Eric Hauser</dc:creator>
		<pubDate>Sun, 15 Feb 2009 22:01:03 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-160</guid>
		<description>I also think you need to think about these things in two contexts.  For the UI, you are talking about tying field level validations to your domain model validations.  This just doesn&#039;t work.  Think about a three tier applications with web services.  Sometimes your DTOs have different field names or do not even directly belong to an entity at all.  In this case, you have no way to directly tie a UI field to a validation.

In the context of submitting an entity, you can certainly run your business rules and return your validation information:

ValidationSummary Insert(SomeInsertMessage m, out int?  id);

But in the context of input validations, I have yet to find an approach where this works nice.  You could do some complicated scheme where you map a UI field to a validation error message that gets returned from the service and incrementally submit, but I doubt that would work very well in practice.</description>
		<content:encoded><![CDATA[<p>I also think you need to think about these things in two contexts.  For the UI, you are talking about tying field level validations to your domain model validations.  This just doesn&#8217;t work.  Think about a three tier applications with web services.  Sometimes your DTOs have different field names or do not even directly belong to an entity at all.  In this case, you have no way to directly tie a UI field to a validation.</p>
<p>In the context of submitting an entity, you can certainly run your business rules and return your validation information:</p>
<p>ValidationSummary Insert(SomeInsertMessage m, out int?  id);</p>
<p>But in the context of input validations, I have yet to find an approach where this works nice.  You could do some complicated scheme where you map a UI field to a validation error message that gets returned from the service and incrementally submit, but I doubt that would work very well in practice.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: derick.bailey</title>
		<link>http://lostechies.com/derickbailey/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both/#comment-159</link>
		<dc:creator>derick.bailey</dc:creator>
		<pubDate>Sun, 15 Feb 2009 21:56:33 +0000</pubDate>
		<guid isPermaLink="false">/blogs/derickbailey/archive/2009/02/15/proactive-vs-reactive-validation-don-t-we-need-both.aspx#comment-159</guid>
		<description>@scott

I understand that a lot of validation is based on the context in which the system is currently running. For example, we had a problem lovingly dubbed &#039;The Z Problem&#039; about 2 years ago. This issue was centered around a user interface that would not allow a &#039;Z&#039; code in an input box, by business rule. But when importing data from a specific external system, &#039;Z&#039; was a valid and common code for that datum. The design, at the time, had &quot;no z&#039;s allowed&quot; coded into the entity, which broke the import process. the &#039;right&#039; solution at the time was to move that particular validation into a service layer so that the UI and the import services could act independently according to their own needs, yet consistently within the domain.

I&#039;ve also seen the problems that using an entity as a ubiquitous data transfer object + domain rules + everything else can cause. I&#039;m dealing with that mess in my current application, by my own fault. 
i&#039;ve been slowly but surely coming around to the realization that i need some sort of presentation model (call it what you wan... the &#039;model&#039; that the UI interacts with directly) in many cases, and not a direct domain model access scenario. it&#039;s this realization that is causing to start asking all these additional questions. I&#039;m still having a hard time understanding, in concrete terms, what should be domain logic and validation vs presentation or other service logic and validation. there are some obvious black &amp; white situations, of course. it&#039;s not the extremes that i&#039;m having a hard time with. it&#039;s the subtle gray areas - the &#039;what feels right&#039; areas - that i&#039;m having a hard time with.

i guess that&#039;s the real crux of my questions - what is entity and domain service validation, vs. what is presentation or other API validation? The real problem is finding a consistent theory or guideline that crosses applications and technologies - even finding guidelines, principles, or theories to cross applications within c# seems to be elusive. i understand what you are saying, abstractly - but until i have a concrete implementation to use as an example, i&#039;m going to have a hard time being able to apply that understanding.</description>
		<content:encoded><![CDATA[<p>@scott</p>
<p>I understand that a lot of validation is based on the context in which the system is currently running. For example, we had a problem lovingly dubbed &#8216;The Z Problem&#8217; about 2 years ago. This issue was centered around a user interface that would not allow a &#8216;Z&#8217; code in an input box, by business rule. But when importing data from a specific external system, &#8216;Z&#8217; was a valid and common code for that datum. The design, at the time, had &#8220;no z&#8217;s allowed&#8221; coded into the entity, which broke the import process. the &#8216;right&#8217; solution at the time was to move that particular validation into a service layer so that the UI and the import services could act independently according to their own needs, yet consistently within the domain.</p>
<p>I&#8217;ve also seen the problems that using an entity as a ubiquitous data transfer object + domain rules + everything else can cause. I&#8217;m dealing with that mess in my current application, by my own fault.<br />
i&#8217;ve been slowly but surely coming around to the realization that i need some sort of presentation model (call it what you wan&#8230; the &#8216;model&#8217; that the UI interacts with directly) in many cases, and not a direct domain model access scenario. it&#8217;s this realization that is causing to start asking all these additional questions. I&#8217;m still having a hard time understanding, in concrete terms, what should be domain logic and validation vs presentation or other service logic and validation. there are some obvious black &#038; white situations, of course. it&#8217;s not the extremes that i&#8217;m having a hard time with. it&#8217;s the subtle gray areas &#8211; the &#8216;what feels right&#8217; areas &#8211; that i&#8217;m having a hard time with.</p>
<p>i guess that&#8217;s the real crux of my questions &#8211; what is entity and domain service validation, vs. what is presentation or other API validation? The real problem is finding a consistent theory or guideline that crosses applications and technologies &#8211; even finding guidelines, principles, or theories to cross applications within c# seems to be elusive. i understand what you are saying, abstractly &#8211; but until i have a concrete implementation to use as an example, i&#8217;m going to have a hard time being able to apply that understanding.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Performance optimized by W3 Total Cache. Learn more: http://www.w3-edge.com/wordpress-plugins/

Page Caching using disk: enhanced

Served from: lostechies.com @ 2012-11-05 08:57:25 -->